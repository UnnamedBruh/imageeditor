<html>
<head></head>
<body>
<img id="image" style="display: none">
<input id="file" type="file" accept="image/png, image/jpeg, image/jpg, image/gif, image/webp, .svg">
<div id="editor">
	<canvas id="currentimage"></canvas>
	<br>
	<select id="effect">
		<option style="color: grey" hidden>Select Effect</option>
		<option disabled style="color: red">Restoration</option>
		<option>Restore Original Image</option>
		<option disabled style="color: red">Filters</option>
		<option disabled style="color: darkred">Color Filters</option>
		<option>R Channel</option>
		<option>G Channel</option>
		<option>B Channel</option>
		<option>Grayscale (by Brightness)</option>
		<option>Grayscale (by Average)</option>
		<option>Black and White</option>
		<option>Brighten</option>
		<option disabled style="color: darkred">Opacity Filters</option>
		<option>All-Opaque</option>
		<option>Opacity Visualization</option>
		<option disabled style="color: red">Compression</option>
		<option>Limit Color Palette</option>
	</select>
	<br>
	<a id="currenteffect"></a>
	<br>
	<label for="param1" id="labelparam1" style="display: none"></label>
	<input id="param1" style="display: none">
	<br>
	<label for="param2" id="labelparam2" style="display: none"></label>
	<input id="param2" style="display: none">
	<br>
	<button id="apply">Apply Effect</button>
</div>
<script>
	const fileInput = document.getElementById('file');
	const imageElement = document.getElementById('image');
	const editor = document.getElementById('editor');
	const canvas = document.getElementById('currentimage');
	const ctx = canvas.getContext('2d');
	const effectSelect = document.getElementById('effect');
	const currentEffect = document.getElementById('currenteffect');
	const applyEffectButton = document.getElementById('apply');
	const params = [
		{
			input: document.getElementById('param1'),
			label: document.getElementById('labelparam1')
		},
		{
			input: document.getElementById('param2'),
			label: document.getElementById('labelparam2')
		}
	];
	fileInput.addEventListener('change', function () {
		const file = fileInput.files[0];
		if (file) {
			const reader = new FileReader();
			reader.onload = function (e) {
				imageElement.src = e.target.result;
				imageElement.style.display = 'none';
				editor.style.display = 'block';
				const img = new Image();
				img.onload = function () {
					canvas.width = img.width;
					canvas.height = img.height;
					ctx.drawImage(img, 0, 0);
				};
				img.src = e.target.result;
			};
			reader.readAsDataURL(file);
		}
	});
	effectSelect.addEventListener('input', function() {
		if (effectSelect.value === "Limit Color Palette") {
			params[0].input.style = ""
			params[0].input.type = "number"
			params[0].input.min = "1"
			params[0].input.max = "255"
			params[0].input.step = "1"
			params[0].label.style = ""
			params[0].label.textContent = "Rounding Number"
		} else if (effectSelect.value === "Brighten") {
			params[0].input.style = ""
			params[0].input.type = "number"
			params[0].input.min = "0"
			params[0].input.max = "255"
			params[0].input.step = "0.2"
			params[0].label.style = ""
			params[0].label.textContent = "Multiplier"
		} else if (effectSelect.value === "Opacity Visualization") {
			params[0].input.style = ""
			params[0].input.type = "checkbox"
			params[0].input.min = ""
			params[0].input.max = ""
			params[0].input.step = ""
			params[0].input.checked = false
			params[0].label.style = ""
			params[0].label.textContent = "Include Invisible Colors"
		} else {
			params[0].input.style = "display: none"
			params[0].label.style = "display: none"
			params[0].label.textContent = ""
		}
	})
	applyEffectButton.addEventListener('click', function () {
		const effect = effectSelect.value;
		if (effect === "Restore Original Image") {
			ctx.drawImage(imageElement, 0, 0);
			return;
		}
		const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
		const data = imgData.data;
		switch (effect) {
			case 'R Channel':
				for (let i = 0; i < data.length; i += 4) {
					data[i + 1] = 0; // Green channel
					data[i + 2] = 0; // Blue channel
				}
				break;
			case 'G Channel':
				for (let i = 0; i < data.length; i += 4) {
					data[i] = 0;     // Red channel
					data[i + 2] = 0; // Blue channel
				}
				break;
			case 'B Channel':
				for (let i = 0; i < data.length; i += 4) {
					data[i] = 0;     // Red channel
					data[i + 1] = 0; // Green channel
				}
				break;
			case 'Grayscale (by Brightness)':
				for (let i = 0; i < data.length; i += 4) {
					const brightness = (0.34 * data[i]) + (0.5 * data[i + 1]) + (0.16 * data[i + 2]);
					data[i] = data[i + 1] = data[i + 2] = brightness;
				}
				break;
			case 'Grayscale (by Average)':
				for (let i = 0; i < data.length; i += 4) {
					const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
					data[i] = data[i + 1] = data[i + 2] = avg;
				}
				break;
			case 'Black and White':
				for (let i = 0; i < data.length; i += 4) {
					const con = Math.floor(((data[i] + data[i + 1] + data[i + 2]) * 1.3) / 665) * 255;
					data[i] = data[i + 1] = data[i + 2] = con;
				}
				break;
			case 'Brighten':
				const round2 = Number(params[0].input.value)
				for (let i = 0; i < data.length; i += 4) {
					data[i] = Math.max(0, Math.min(255, Math.round(data[i] * round2)));
					data[i + 1] = Math.max(0, Math.min(255, Math.round(data[i + 1] * round2)));
					data[i + 2] = Math.max(0, Math.min(255, Math.round(data[i + 2] * round2)));
				}
				break;
			case 'Invert Color':
				for (let i = 0; i < data.length; i += 4) {
					data[i] = 255 - data[i];
					data[i + 1] = 255 - data[i + 1];
					data[i + 2] = 255 - data[i + 2];
				}
				break;
			case 'Limit Color Palette':
				const round = Number(params[0].input.value)
				for (let i = 0; i < data.length; i += 4) {
					data[i] = Math.max(0, Math.min(255, Math.round(data[i] / round) * round));
					data[i + 1] = Math.max(0, Math.min(255, Math.round(data[i + 1] / round) * round));
					data[i + 2] = Math.max(0, Math.min(255, Math.round(data[i + 2] / round) * round));
				}
				break;
			case 'Full Opaqueness':
				for (let i = 3; i < data.length; i += 4) {
					data[i] = 255;
				}
				break;
			case 'Opacity Visualization':
				const checked = !params[0].input.checked
				for (let i = 0; i < data.length; i += 4) {
					data[i] = data[i + 1] = data[i + 2] = data[i + 3];
					data[i + 3] = (checked && data[i + 3] === 0) ? 0 : 255;
				}
				break;
		}
		ctx.putImageData(imgData, 0, 0);
		currentEffect.textContent = `Current Effect: ${effect}`;
	});
</script>
</body>
</html>
